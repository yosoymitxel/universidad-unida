PARSER_BEGIN(Calculadora)

// Paquete y librerías necesarias
import java.io.*;
import java.util.*;

public class Calculadora {

    public static void main(String[] args) throws ParseException {
        Scanner entradaEscaner = new Scanner(System.in);
		while (true) { // Ciclo infinito
        	System.out.print("Ingrese una expresión: ");
	        String calculo = entradaEscaner.nextLine();
	
	        // Intenta parsear la expresión y manejar la excepción ParseException
	        try {
	            Calculadora parser = new Calculadora(new StringReader(calculo));
	
				
            	double result = parser.Expression();
				
	    		
	            // Redondear valores muy pequeños a cero
	            if (Math.abs(result) < 1e-10) result = 0.0;
	            	System.out.println("Resultado: " + result);
	        } catch (TokenMgrError e) {
			    System.err.println("Error léxico: " + e.getMessage());
			} catch (ParseException e) {
			    System.err.println("Error sintáctico: " + e.getMessage());
			}
		        // Limpiar la pantalla (opcional)
	        System.out.print("\033[H\033[2J"); // Limpia la pantalla en la mayoría de terminales
	
	        System.out.print("¿Desea ingresar otra expresión? (s/n): ");
	        String continuar = entradaEscaner.nextLine();
	
	        if (!continuar.equalsIgnoreCase("s")) {
	            break; // Salir del bucle si no se ingresa "s"
	        }
	    }
    }

    public static double sin(double x) {
        return Math.sin(Math.toRadians(x)); // Convertir grados a radianes para función sin
    }

    public static double cos(double x) {
        return Math.cos(Math.toRadians(x)); // Convertir grados a radianes para función cos
    }

    public static double tan(double x) {
        return Math.tan(Math.toRadians(x)); // Convertir grados a radianes para función tan
    }
}

// Ignorar espacios, tabuladores, saltos de línea y retorno de carro
PARSER_END(Calculadora)

SKIP: { " " | "\t" | "\n" | "\r" }

// Definición de tokens
TOKEN: {
    < PLUS: "+" > |
    < MINUS: "-" > |
    < MULT: "*" > |
    < DIV: "/" > |
    < LPAREN: "(" > |
    < RPAREN: ")" > |
    < NUMBER: (["0"-"9"])+("."(["0"-"9"])+)? > |  // Patrón para números (enteros y decimales)
    < SIN: "sin" > |
    < COS: "cos" > |
    < TAN: "tan" >
}

// Método para la expresión (principal)
double Expression() :
{
    double result, term;
    Token t;
}
{
    result = Term()
    // Bucle para manejar sumas y restas sucesivas
    (
        ( t = <PLUS> | t = <MINUS> ) term = Term() {  // Coincide con un signo (+ o -) seguido de un término
            if (t.kind == PLUS) result += term; // Si es +, suma el término
            else result -= term;               // Si es -, resta el término
        }
    )*
    { return result; }  // Devuelve el resultado final
}

// Método para el término
double Term() :
{
    double result, factor;
    Token t;
}
{
    result = Factor()
    // Bucle para manejar multiplicaciones y divisiones sucesivas
    (
        ( t = <MULT> | t = <DIV> ) factor = Factor() {  // Coincide con un operador (* o /) seguido de un factor
            if (t.kind == MULT) result *= factor; // Si es *, multiplica por el factor
            else {  // Si es /
                // Manejo de división por cero
                if (factor == 0) {
                    throw new ArithmeticException("Error: División por cero");
                } else {
                    result /= factor;
                }
            }
        }
    )*
    { return result; }  // Devuelve el resultado final
}

// Método para el factor
double Factor() :
{
    Token t;
    double result;
}
{
    // Manejo de números
    t = <NUMBER> { return Double.parseDouble(t.image); }
    // Manejo de expresiones entre paréntesis
    | <LPAREN> result = Expression() <RPAREN> { return result; }
    // Manejo de funciones trigonométricas
    | <SIN> <LPAREN> result = Expression() <RPAREN> { return Calculadora.sin(result); }
    | <COS> <LPAREN> result = Expression() <RPAREN> { return Calculadora.cos(result); }
    | <TAN> <LPAREN> result = Expression() <RPAREN> {
        // Verificación de argumento válido para la tangente (evitar tangente de 90 grados)
        if (Math.abs(result - Math.PI / 2) < 1e-10) {
            throw new ArithmeticException("Error: Tangente indefinida (ángulo cercano a 90 grados)");
        } else {
            return Calculadora.tan(result);
        }
    }
}